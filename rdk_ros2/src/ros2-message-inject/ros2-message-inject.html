<script type="text/html" data-template-name="ROS2 Inject">
    <div class="form-row node-input-property-container-row">
        <ol id="node-input-property-container"></ol>
    </div>

    <div class="form-row" id="node-once">
        <label for="node-input-once">&nbsp;</label>
        <input type="checkbox" id="node-input-once" style="display:inline-block; width:15px; vertical-align:baseline;">
        <span>Inject once after </span>&nbsp;
        <input type="text" id="node-input-onceDelay" placeholder="0.1" style="width:45px; height:28px;">&nbsp;
        <span> seconds, then</span>
    </div>

    <div class="form-row">
        <label for=""><i class="fa fa-repeat"></i>&nbsp; Repeat</label>
        <select id="inject-time-type-select">
            <option value="none">none</option>
            <option value="interval">interval</option>
            <option value="interval-time">interval between times</option>
            <option value="time">at specific time</option>
        </select>
        <input type="hidden" id="node-input-repeat">
        <input type="hidden" id="node-input-crontab">
    </div>

    <div class="form-row inject-time-row hidden" id="inject-time-row-interval">
        <span>every</span>
        <input id="inject-time-interval-count" class="inject-time-count" value="1"></input>
        <select style="width:100px" id="inject-time-interval-units">
            <option value="s">seconds</option>
            <option value="m">minutes</option>
            <option value="h">hours</option>
        </select><br/>
    </div>

    <div class="form-row inject-time-row hidden" id="inject-time-row-interval-time">
        <span>every</span> <select style="width:90px; margin-left:20px;" id="inject-time-interval-time-units" class="inject-time-int-count" value="1">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="10">10</option>
            <option value="12">12</option>
            <option value="15">15</option>
            <option value="20">20</option>
            <option value="30">30</option>
            <option value="0">60</option>
        </select> <span>minutes</span><br/>
        <span>between</span> <select id="inject-time-interval-time-start" class="inject-time-times"></select>
        <span>and</span> <select id="inject-time-interval-time-end" class="inject-time-times"></select><br/>
        <div id="inject-time-interval-time-days" class="inject-time-days" style="margin-top:5px">
            <div style="display:inline-block; vertical-align:top; margin-right:5px;">on</div>
            <div style="display:inline-block;">
                <div>
                    <label><input type='checkbox' checked value='1'/> <span>Monday</span></label>
                    <label><input type='checkbox' checked value='2'/> <span>Tuesday</span></label>
                    <label><input type='checkbox' checked value='3'/> <span>Wednesday</span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='4'/> <span>Thursday</span></label>
                    <label><input type='checkbox' checked value='5'/> <span>Friday</span></label>
                    <label><input type='checkbox' checked value='6'/> <span>Saturday</span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='0'/> <span>Sunday</span></label>
                </div>
            </div>
        </div>
    </div>

    <div class="form-row inject-time-row hidden" id="inject-time-row-time">
        <span>at</span> <input type="text" id="inject-time-time" value="12:00"></input><br/>
        <div id="inject-time-time-days" class="inject-time-days">
            <div style="display:inline-block; vertical-align:top; margin-right:5px;">on</div>
            <div style="display:inline-block;">
                <div>
                    <label><input type='checkbox' checked value='1'/> <span>Monday</span></label>
                    <label><input type='checkbox' checked value='2'/> <span>Tuesday</span></label>
                    <label><input type='checkbox' checked value='3'/> <span>Wednesday</span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='4'/> <span>Thursday</span></label>
                    <label><input type='checkbox' checked value='5'/> <span>Friday</span></label>
                    <label><input type='checkbox' checked value='6'/> <span>Saturday</span></label>
                </div>
                <div>
                    <label><input type='checkbox' checked value='0'/> <span>Sunday</span></label>
                </div>
            </div>
        </div>
    </div>

</script>
<style>
    .inject-time-row {
        padding-left: 110px;
    }
    .inject-time-row select {
        margin: 3px 0;
    }
    .inject-time-days label {
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        vertical-align: baseline;
        width: 100px;
    }
    .inject-time-days input {
        width: auto !important;
        vertical-align: baseline !important;
    }
    .inject-time-times {
        width: 90px !important;
    }
    #inject-time-time {
        width: 75px;
        margin-left: 8px;
        margin-bottom: 8px;
    }
    .inject-time-count {
        width: 40px !important;
    }
</style>

<script type="text/javascript">
(function() {

    function resizeDialog(size) {
        size = size || { height: $(".red-ui-tray-content form").height() }
        var rows = $("#dialog-form>div:not(.node-input-property-container-row):visible");
        var height = size.height;
        for (var i=0; i<rows.length; i++) {
            height -= $(rows[i]).outerHeight(true);
        }
        var editorRow = $("#dialog-form>div.node-input-property-container-row");
        height -= (parseInt(editorRow.css("marginTop"))+parseInt(editorRow.css("marginBottom")));
        height += 16;
        $("#node-input-property-container").editableList('height',height);
    }

    var types_dict = {'std::string' : 'str', 'char' : 'str', 'char16_t' : 'str', 'wchar_t' : 'str', 'float' : 'num', 'double' : 'num',
        'long double' : 'num', 'int8_t' : 'num', 'int16_t' : 'num', 'int32_t' : 'num', 'int64_t' : 'num', 'uint8_t' : 'num', 'uint16_t' : 'num',
        'uint32_t' : 'num', 'uint64_t' : 'num', 'bool' : 'bool'};
    var containers = ['sequence', 'array', 'map', 'enum', 'union'];

    var custom_struct = {};

    function processIDL(idl_str, pkg, msg, node, n) {

        var params = {};
        var type_name = "";
        var complete_name = "";

        if (idl_str)
        {
            params['idl'] = idl_str;
            type_name = n.target.name;
            complete_name = n.target.name;
        }
        else
        {
            params['package'] = pkg;
            params['msg'] = msg;
            type_name = n.target.ros2message;
            complete_name = n.target.ros2pkg + "::msg::" + n.target.ros2message;
        }

        $.getJSON('getidl', params, function(idl)
        {
            //Array [[ 0: Struct name, 1: { member: type }], ...]
            idl.forEach( function(struct)
            {
                if (struct[0] != type_name || !Object.keys(custom_struct).includes(struct[0]))
                {
                    custom_struct[struct[0]] = [];
                }
                Object.keys(struct[1]).forEach( function(member)
                {
                    var type = "";
                    var default_value = "";
                    var member_type = struct[1][member];

                    // Basic Types
                    if (Object.keys(types_dict).includes(member_type))
                    {
                        type = types_dict[member_type];
                    }
                    else
                    {
                        // container type_length_inner type
                        var underscore_idx = member_type.indexOf('_');
                        var container_type = member_type;
                        if (underscore_idx != -1)
                        {
                            container_type = member_type.substr(0, underscore_idx);
                        }
                        switch (container_type)
                        {
                            case 'array':
                            case 'sequence':
                                member_type = member_type.substr(underscore_idx + 1);
                                underscore_idx = member_type.indexOf('_');
                                if (underscore_idx != -1)
                                {
                                    var length = member_type.substr(0, underscore_idx);
                                    if (!isNaN(parseInt(length)))
                                    {
                                        member_type = member_type.substr(underscore_idx + 1);
                                    }
                                }
                                type = 'json';
                                default_value = "[]";
                                break;
                            case 'map':
                            case 'enum':
                            case 'union':
                                type = 'json';
                                default_value = "{}";
                                break;
                        }
                    }

                    // Main Struct Members
                    if (complete_name == struct[0])
                    {
                        // Basic Types
                        if (type != "")
                        {
                            var m = { p: member, v: default_value, vt: type, t: struct[1][member] };
                            var old = node.props.filter(p => p.p == m.p && p.vt != m.vt);
                            if (old.length > 0)
                            {
                                var idx = node.props.indexOf(old[0]);
                                node.props.splice(idx, 1);
                            }
                            if (!node.props.some(p => p.p == m.p && p.vt == m.vt))
                            {
                                node.props.push(m);
                            }
                        }
                        // Custom Types
                        else if (type == "" && Object.keys(custom_struct).includes(member_type))
                        {
                            var is_container = containers.some(c => struct[1][member].includes(c));
                            custom_struct[member_type].forEach( function(mem)
                            {
                                var aux = {};
                                aux.p = mem.p; aux.t = mem.t;
                                aux.v = (is_container && Object.keys(types_dict).includes(mem.t)) ? "[]" : mem.v;
                                aux.vt = (is_container && Object.keys(types_dict).includes(mem.t)) ? "json" : mem.vt;
                                aux.p = member + '.' + aux.p;

                                var old = node.props.filter(p => p.p == aux.p && p.vt != aux.vt);
                                if (old.length > 0)
                                {
                                    var idx = node.props.indexOf(old[0]);
                                    node.props.splice(idx, 1);
                                }
                                if (!node.props.some(p => p.p == aux.p && p.vt == aux.vt))
                                {
                                    node.props.push(aux);
                                }
                            });
                        }
                    }
                    // Custom Structures
                    else if (complete_name != struct[0])
                    {
                        // Basic Types
                        if (type != "")
                        {
                            custom_struct[struct[0]].push({ p: member, v: default_value, vt: type, t: struct[1][member]});
                        }
                        // Custom Types
                        else if (type == "" && Object.keys(custom_struct).includes(member_type))
                        {
                            custom_struct[member_type].forEach( function(mem)
                            {
                                var aux = {};
                                aux.p = mem.p; aux.v = mem.v; aux.vt = mem.vt; aux.t = mem.t;
                                aux.p = member + '.' + aux.p;
                                custom_struct[struct[0]].push(aux);
                            });
                        }
                    }
                });
            });
            // Add the type fields to the property container
            if (idl_str)
            {
                custom_struct[Object.keys(custom_struct)[0]].forEach(p => $("#node-input-property-container").editableList('addItem', p));
            }
            else
            {
                node.props.forEach(p => $("#node-input-property-container").editableList('addItem', p));
            }
        });
    }

    RED.nodes.registerType('ROS2 Inject',{
        category: 'RDK ROS2',
        color: "#ddd",
        defaults: {
            types: { value: [] },
            props:{ value:[] },
            repeat: {value:"", validate:function(v) { return ((v === "") || (RED.validators.number(v) && (v >= 0) && (v <= 2147483))) }},
            crontab: {value:""},
            once: {value:false},
            onceDelay: {value:0.1},
            topic: {value:""},
            ros2type: { value:"" },
            idltype: {value: "" }
        },
        icon: "ros2-icon.svg",
        inputs:0,
        outputs:1,
        outputLabels: function(i)
        {
            return "Type";
        },
        label: function() {
            return "ROS2 Inject";
        },
        oneditprepare: function() {
            var node = this;

            $('#node-input-property-container').css('min-height','120px').css('min-width','450px').editableList({
                addItem: function(container, i, opt) {
                    var prop = opt;
                    if (!prop.hasOwnProperty('p')) {
                        prop = {p:"", v:"", vt:"str", t: ""};
                    }
                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });
                    var row = $('<div/>', {id:"container-row"}).appendTo(container);

                    row.attr("title", prop.t);

                    var propertyName = $('<input/>',{class:"node-input-prop-property-name",type:"text"})
                        .css("width","30%")
                        .appendTo(row)
                        .typedInput({types:['msg']});

                    var valueLength = "calc(70% - 30px)";

                    var found = Object.keys(custom_struct).filter(c => prop.t.includes(c));
                    // Sort to get the most accurate type
                    found.sort(function (a, b) {
                        if (a.length > b.length) {
                            return -1;
                        }
                        if (a.length < b.length) {
                            return 1;
                        }
                        return 0;
                    });

                    // Include a button to add new elements to complex type sequences
                    if (prop.t.includes("sequence") && found.length > 0)
                    {
                        var n = found[0];
                        var newElement = $('<button/>', {class:"node-input-prop-property-add", text:"+"})
                            .css("padding", "2px")
                            .appendTo(row)
                            .click(function()
                            {
                                var new_mem = "";
                                var inner_length = custom_struct[n].length;
                                var old_value = prop.v.replace(/([ \[\]])/mg, '');
                                if (old_value.length != 0)
                                {
                                    new_mem = old_value + ',';
                                }
                                var json = {};
                                custom_struct[n].forEach( function(mem)
                                {
                                    var index = mem.p.indexOf('.');
                                    var previous_idx = 0;
                                    var level = json;
                                    var level_name = mem.p;
                                    while (index != -1)
                                    {
                                        level_name = mem.p.substr(previous_idx, index - previous_idx);
                                        if (!Object.keys(level).includes(level_name)){
                                            level[level_name] = {};
                                        }
                                        level = level[level_name];
                                        previous_idx = index + 1;
                                        index = mem.p.indexOf('.', previous_idx);

                                        if (index == -1)
                                        {
                                            level_name = mem.p.substr(previous_idx);
                                        }
                                    }
                                    switch(mem.vt)
                                    {
                                        case 'str':
                                            level[level_name] = ""; break;
                                        case 'num':
                                            level[level_name] = 0; break;
                                        case 'bool':
                                            level[level_name] = false; break;
                                    }
                                });
                                new_mem += JSON.stringify(json);
                                if (new_mem.length != 0)
                                {
                                    prop.v = "[" + new_mem + "]";
                                    $('.node-input-prop-property-value[name="'+ prop.p +'"]').typedInput('value', prop.v);
                                    $('.red-ui-editableList-item-content > div[name="'+ prop.p +'"] :button.red-ui-typedInput-option-expand:visible')
                                    .trigger('click');
                                }
                            });

                        valueLength = "calc(65% - 30px)";
                    }

                    $('<div/>',{style: 'display:inline-block; padding:0px 6px;'})
                        .text('=')
                        .appendTo(row);

                    var propertyValue = $('<input/>',{class:"node-input-prop-property-value",type:"text"})
                        .css("width", valueLength)
                        .appendTo(row)
                        .typedInput({default:'str', types:['str','num','bool','json']})
                        .on('change', function(event, type, value)
                        {
                            prop.v = value;
                        });

                    if (prop.vt == 'json')
                    {
                        propertyValue.attr('name', prop.p);
                        row.attr('name', prop.p);
                    }

                    propertyName.typedInput('value', prop.p);

                    propertyValue.typedInput('value', prop.v);
                    propertyValue.typedInput('type', prop.vt);
                },
                removable: true,
                sortable: true
            });

            node.props = [];
            custom_struct = [];

            // Checks each link connected to this node
            RED.nodes.eachLink( function(n)
            {
                if (n.source.id == node.id)
                {
                    switch(n.target.type)
                    {
                        case "ROS2 Type":
                            if (n.target.validationErrors.length > 0)
                            {
                                RED.notify("The type must be configured before", "error");
                            }
                            else
                            {
                                if (node.idltype != "")
                                {
                                    node.idltype = "";
                                }
                                if (node.ros2type != n.target.ros2pkg + '/' + n.target.ros2message)
                                {
                                    node.ros2type = n.target.ros2pkg + '/' + n.target.ros2message;
                                    node.props = [];
                                }

                                processIDL("", n.target.ros2pkg, n.target.ros2message, node, n);
                            }
                            break;
                        case "IDL Type":
                            if (n.target.validationErrors.length > 0)
                            {
                                RED.notify("The type must be configured before", "error");
                            }
                            else
                            {
                                if (node.ros2type != "")
                                {
                                    node.ros2type = "";
                                }
                                if (node.idltype != n.target.name)
                                {
                                    node.idltype = n.target.name;
                                    node.props = [];
                                }

                                processIDL(n.target.idltype, "", "", node, n);
                            }
                            break;
                    }
                }
            });

            $("#inject-time-type-select").on("change", function() {
                $("#node-input-crontab").val('');
                var id = $("#inject-time-type-select").val();
                $(".inject-time-row").hide();
                $("#inject-time-row-"+id).show();
                if ((id == "none") || (id == "interval") || (id == "interval-time")) {
                    $("#node-once").show();
                }
                else {
                    $("#node-once").hide();
                    $("#node-input-once").prop('checked', false);
                }

                // Scroll down
                var scrollDiv = $("#dialog-form").parent();
                scrollDiv.scrollTop(scrollDiv.prop('scrollHeight'));
                resizeDialog();
            });

            $("#node-input-once").on("change", function() {
                $("#node-input-onceDelay").attr('disabled', !$("#node-input-once").prop('checked'));
            })

            $(".inject-time-times").each(function() {
                for (var i=0; i<24; i++) {
                    var l = (i<10?"0":"")+i+":00";
                    $(this).append($("<option></option>").val(i).text(l));
                }
            });
            $("<option></option>").val(24).text("00:00").appendTo("#inject-time-interval-time-end");
            $("#inject-time-interval-time-start").on("change", function() {
                var start = Number($("#inject-time-interval-time-start").val());
                var end = Number($("#inject-time-interval-time-end").val());
                $("#inject-time-interval-time-end option").remove();
                for (var i=start+1; i<25; i++) {
                    var l = (i<10?"0":"")+i+":00";
                    if (i==24) {
                        l = "00:00";
                    }
                    var opt = $("<option></option>").val(i).text(l).appendTo("#inject-time-interval-time-end");
                    if (i === end) {
                        opt.attr("selected","selected");
                    }
                }
            });

            $(".inject-time-count").spinner({
                //max:60,
                min:1
            });

            var repeattype = "none";
            if (this.repeat != "" && this.repeat != 0) {
                repeattype = "interval";
                var r = "s";
                var c = this.repeat;
                if (this.repeat % 60 === 0) { r = "m"; c = c/60; }
                if (this.repeat % 1440 === 0) { r = "h"; c = c/60; }
                $("#inject-time-interval-count").val(c);
                $("#inject-time-interval-units").val(r);
                $("#inject-time-interval-days").prop("disabled","disabled");
            } else if (this.crontab) {
                var cronparts = this.crontab.split(" ");
                var days = cronparts[4];
                if (!isNaN(cronparts[0]) && !isNaN(cronparts[1])) {
                    repeattype = "time";
                    // Fixed time
                    var time = cronparts[1]+":"+cronparts[0];
                    $("#inject-time-time").val(time);
                    $("#inject-time-type-select").val("s");
                    if (days == "*") {
                        $("#inject-time-time-days input[type=checkbox]").prop("checked",true);
                    } else {
                        $("#inject-time-time-days input[type=checkbox]").removeAttr("checked");
                        days.split(",").forEach(function(v) {
                            $("#inject-time-time-days [value=" + v + "]").prop("checked", true);
                        });
                    }
                } else {
                    repeattype = "interval-time";
                    // interval - time period
                    var minutes = cronparts[0].slice(2);
                    if (minutes === "") { minutes = "0"; }
                    $("#inject-time-interval-time-units").val(minutes);
                    if (days == "*") {
                        $("#inject-time-interval-time-days input[type=checkbox]").prop("checked",true);
                    } else {
                        $("#inject-time-interval-time-days input[type=checkbox]").removeAttr("checked");
                        days.split(",").forEach(function(v) {
                            $("#inject-time-interval-time-days [value=" + v + "]").prop("checked", true);
                        });
                    }
                    var time = cronparts[1];
                    var timeparts = time.split(",");
                    var start;
                    var end;
                    if (timeparts.length == 1) {
                        // 0 or 0-10
                        var hours = timeparts[0].split("-");
                        if (hours.length == 1) {
                            if (hours[0] === "") {
                                start = "0";
                                end = "0";
                            }
                            else {
                                start = hours[0];
                                end = Number(hours[0])+1;
                            }
                        } else {
                            start = hours[0];
                            end = Number(hours[1])+1;
                        }
                    } else {
                        // 23,0 or 17-23,0-10 or 23,0-2 or 17-23,0
                        var startparts = timeparts[0].split("-");
                        start = startparts[0];

                        var endparts = timeparts[1].split("-");
                        if (endparts.length == 1) {
                            end = Number(endparts[0])+1;
                        } else {
                            end = Number(endparts[1])+1;
                        }
                    }
                    $("#inject-time-interval-time-end").val(end);
                    $("#inject-time-interval-time-start").val(start);

                }
            } else {
                $("#inject-time-type-select").val("none");
            }

            $(".inject-time-row").hide();
            $("#inject-time-type-select").val(repeattype);
            $("#inject-time-row-"+repeattype).show();

            $("#inject-time-type-select").trigger("change");
            $("#inject-time-interval-time-start").trigger("change");

        },
        oneditsave: function() {
            var repeat = "";
            var crontab = "";
            var type = $("#inject-time-type-select").val();
            if (type == "none") {
                // nothing
            } else if (type == "interval") {
                var count = $("#inject-time-interval-count").val();
                var units = $("#inject-time-interval-units").val();
                if (units == "s") {
                    repeat = count;
                } else {
                    if (units == "m") {
                        //crontab = "*/"+count+" * * * "+days;
                        repeat = count * 60;
                    } else if (units == "h") {
                        //crontab = "0 */"+count+" * * "+days;
                        repeat = count * 60 * 60;
                    }
                }
            } else if (type == "interval-time") {
                repeat = "";
                var count = $("#inject-time-interval-time-units").val();
                var startTime = Number($("#inject-time-interval-time-start").val());
                var endTime = Number($("#inject-time-interval-time-end").val());
                var days = $('#inject-time-interval-time-days input[type=checkbox]:checked').map(function(_, el) {
                    return $(el).val()
                }).get();
                if (days.length == 0) {
                    crontab = "";
                } else {
                    if (days.length == 7) {
                        days="*";
                    } else {
                        days = days.join(",");
                    }
                    var timerange = "";
                    if (endTime == 0) {
                        timerange = startTime+"-23";
                    } else if (startTime+1 < endTime) {
                        timerange = startTime+"-"+(endTime-1);
                    } else if (startTime+1 == endTime) {
                        timerange = startTime;
                    } else {
                        var startpart = "";
                        var endpart = "";
                        if (startTime == 23) {
                            startpart = "23";
                        } else {
                            startpart = startTime+"-23";
                        }
                        if (endTime == 1) {
                            endpart = "0";
                        } else {
                            endpart = "0-"+(endTime-1);
                        }
                        timerange = startpart+","+endpart;
                    }
                    if (count === "0") {
                        crontab = count+" "+timerange+" * * "+days;
                    } else {
                        crontab = "*/"+count+" "+timerange+" * * "+days;
                    }
                }
            } else if (type == "time") {
                var time = $("#inject-time-time").val();
                var days = $('#inject-time-time-days  input[type=checkbox]:checked').map(function(_, el) {
                    return $(el).val()
                }).get();
                if (days.length == 0) {
                    crontab = "";
                } else {
                    if (days.length == 7) {
                        days="*";
                    } else {
                        days = days.join(",");
                    }
                    var parts = time.split(":");
                    if (parts.length === 2) {
                        repeat = "";
                        parts[1] = ("00" + (parseInt(parts[1]) % 60)).substr(-2);
                        parts[0] = ("00" + (parseInt(parts[0]) % 24)).substr(-2);
                        crontab = parts[1]+" "+parts[0]+" * * "+days;
                    }
                    else { crontab = ""; }
                }
            }

            $("#node-input-repeat").val(repeat);
            $("#node-input-crontab").val(crontab);

            /* Gather the injected properties of the msg object */
            var props = $("#node-input-property-container").editableList('items');
            var node = this;
            node.props= [];
            props.each(function(i) {
                var prop = $(this);
                var p = {
                    p:prop.find(".node-input-prop-property-name").typedInput('value')
                };
                if (p.p) {
                    p.v = prop.find(".node-input-prop-property-value").typedInput('value');
                    p.vt = prop.find(".node-input-prop-property-value").typedInput('type');
                    p.t = prop.find("#container-row").attr("title");

                    if (Object.keys(types_dict).includes(p.t) && p.vt != types_dict[p.t] && p.vt != 'json')
                    {
                        var error_msg = "Field " + p.p + " has a wrong type";
                        RED.notify(error_msg, "error");
                    }

                    // container type_length_inner type
                    var underscore_idx = p.t.indexOf('_');
                    var container_type = p.t;
                    if (underscore_idx != -1)
                    {
                        container_type = p.t.substr(0, underscore_idx);
                    }
                    switch(container_type)
                    {
                        case 'array':
                            var length = p.t.substr(underscore_idx + 1);
                            underscore_idx = length.indexOf('_');

                            length = parseInt(length.substr(0, underscore_idx));
                            var type = p.t.substr( 6 +/*array_*/ underscore_idx + 1);
                            var elements = JSON.parse(p.v);
                            if (elements.length > length || (elements.length < length && !Object.keys(types_dict).includes(type)))
                            {
                                var error_msg = "The length of the array " + p.p + " must be " + length;
                                RED.notify(error_msg, "error");
                            }
                            else if (elements.length < length)
                            {
                                type = types_dict[type];
                                var default_val = "";
                                switch(type)
                                {
                                    case 'num':
                                        default_val = 0; break;
                                    case 'bool':
                                        default_val = false; break;
                                }
                                var remaining = new Array(length - elements.length);
                                remaining.fill(default_val, 0);
                                p.v = JSON.stringify(elements.concat(remaining));
                            }
                            break;
                        case 'sequence':
                            var length = p.t.substr(underscore_idx + 1);
                            underscore_idx = length.indexOf('_');
                            if (underscore_idx != -1)
                            {
                                length = parseInt(length.substr(0, underscore_idx));
                                if (!isNaN(length))
                                {
                                    var elements = JSON.parse(p.v);
                                    if (elements.length > length)
                                    {
                                        var error_msg = "The length of the sequence " + p.p + " must lower or equal than " + length;
                                        RED.notify(error_msg, "error");
                                    }
                                }
                            }
                            break;
                        case 'map':
                        case 'enum':
                        case 'union':
                    }

                    node.props.push(p);
                }
            });
        },
        button: {
            enabled: function() {
                return !this.changed
            },
            onclick: function() {
                if (this.changed) {
                    return RED.notify(RED._("notification.warning", {message:RED._("notification.warnings.undeployedChanges")}),"warning");
                }

                var label = this._def.label.call(this);
                if (label.length > 30) {
                    label = label.substring(0,50)+"...";
                }
                label = label.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
                var node = this;
                $.ajax({
                    url: "inject/"+this.id+"/"+JSON.stringify(node.props),
                    type:"POST",
                    success: function(resp) {
                        if (node.status && node.status.fill == "yellow")
                        {
                            RED.notify("Please wait until Visual-ROS is ready to be used","error");
                        }
                        else
                        {
                            RED.notify("Message injected successfully", {type:"success", id:"ROS2 Inject"});
                        }
                    },
                    error: function(jqXHR,textStatus,errorThrown) {
                        if (jqXHR.status == 404) {
                            RED.notify("There are undeployed changes in this node","error");
                        } else if (jqXHR.status == 500) {
                            RED.notify("Message injection failed","error");
                        } else if (jqXHR.status == 0) {
                            RED.notify("There is no response","error");
                        } else {
                            RED.notify(node._("Error",{message:node._("Unexpected error",{status:jqXHR.status,message:textStatus})}),"error");
                        }
                    }
                });
            }
        },
        oneditresize: resizeDialog
    });
})();
</script>

<!--Help text shown for the ROS2 Inject node-->
<script type="text/html" data-help-name="ROS2 Inject">
    <p>Injects a ROS 2 message into a flow either manually or at regular intervals. The message content is defined by the
    type defined.</p>
    <h3>Details</h3>
        <p> This node analyze the IDL definition corresponding to the data type selected in the adjacent type node,
        extracts the fields that needs to be filled in and shows them to the user in a list alongs with its type.</p>
        <p>By default, the node is triggered manually by clicking on its button within the editor. It can also be set to
         inject at regular intervals or according to a schedule.</p>
        <p>It can also be configured to inject once each time the flows are started.</p>
        <p>The maximum Interval that can be specified is about 596 hours / 24 days. However if you are looking at
        intervals greater than one day you should consider using a scheduler node that can cope with power outages and
        restarts.</p>
        <p><b>Note</b>: The "Interval between times" and "at a specific time" options use the standard cron system.
        This means that 20 minutes will be at the next hour, 20 minutes past and 40 minutes past - not in 20 minutes time.
        If you want every 20 minutes from now - use the "interval" option.</p>
        <p><b>Note</b>: To include a newline in a string you must use a Function node to create the payload.</p>
        <p><b>Note</b>: This node must be linked to a type node (IDL type or ROS2 Type).</p>
</script>
